/* tslint:disable */
/* eslint-disable */
/**
 * Drip Backend
 * Drip backend service. All API\'s have a IP rate limit of 10 requests per second. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: mocha@dcaf.so
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CurrentTVLResponse,
  ErrorResponse,
  MintRequest,
  MintResponse,
  OrcaWhirlpoolConfig,
  PingResponse,
  Position,
  ProtoConfig,
  SplTokenSwapConfig,
  Token,
  TokenMetadata,
  Vault,
  VaultPeriod,
} from '../models';
import {
    CurrentTVLResponseFromJSON,
    CurrentTVLResponseToJSON,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    MintRequestFromJSON,
    MintRequestToJSON,
    MintResponseFromJSON,
    MintResponseToJSON,
    OrcaWhirlpoolConfigFromJSON,
    OrcaWhirlpoolConfigToJSON,
    PingResponseFromJSON,
    PingResponseToJSON,
    PositionFromJSON,
    PositionToJSON,
    ProtoConfigFromJSON,
    ProtoConfigToJSON,
    SplTokenSwapConfigFromJSON,
    SplTokenSwapConfigToJSON,
    TokenFromJSON,
    TokenToJSON,
    TokenMetadataFromJSON,
    TokenMetadataToJSON,
    VaultFromJSON,
    VaultToJSON,
    VaultPeriodFromJSON,
    VaultPeriodToJSON,
} from '../models';

export interface MintPostRequest {
    mintRequest: MintRequest;
}

export interface V1DripOrcawhirlpoolconfigsGetRequest {
    vault?: string;
}

export interface V1DripPositionPubkeyPathMetadataGetRequest {
    pubkeyPath: string;
}

export interface V1DripPubkeyPathTokenmetadataGetRequest {
    pubkeyPath: string;
}

export interface V1DripSpltokenswapconfigsGetRequest {
    vault?: string;
}

export interface V1PositionsGetRequest {
    wallet: string;
    isClosed?: boolean;
    offset?: number;
    limit?: number;
}

export interface V1ProtoconfigsGetRequest {
    tokenA?: string;
    tokenB?: string;
}

export interface V1TokenPubkeyPathGetRequest {
    pubkeyPath: string;
}

export interface V1VaultTokensGetRequest {
    tokenA?: string;
    tokenB?: string;
}

export interface V1VaultperiodsGetRequest {
    vault: string;
    vaultPeriod?: string;
    offset?: number;
    limit?: number;
}

export interface V1VaultsGetRequest {
    tokenA?: string;
    tokenB?: string;
    protoConfig?: string;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * mint test tokens to a desired associated token account, or passed in token account
     * Mint tokens (DEVNET ONLY)
     */
    async mintPostRaw(requestParameters: MintPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MintResponse>> {
        if (requestParameters.mintRequest === null || requestParameters.mintRequest === undefined) {
            throw new runtime.RequiredError('mintRequest','Required parameter requestParameters.mintRequest was null or undefined when calling mintPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/mint`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MintRequestToJSON(requestParameters.mintRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MintResponseFromJSON(jsonValue));
    }

    /**
     * mint test tokens to a desired associated token account, or passed in token account
     * Mint tokens (DEVNET ONLY)
     */
    async mintPost(requestParameters: MintPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MintResponse> {
        const response = await this.mintPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Ping api.
     * Health Check
     */
    async rootGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PingResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PingResponseFromJSON(jsonValue));
    }

    /**
     * Ping api.
     * Health Check
     */
    async rootGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PingResponse> {
        const response = await this.rootGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Swagger spec
     */
    async swaggerJsonGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/swagger.json`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Swagger spec
     */
    async swaggerJsonGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.swaggerJsonGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get TVL across all Drip Vaults.
     * Get current TVL across all vaults.
     */
    async v1AnalyticsTvlGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CurrentTVLResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/analytics/tvl`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CurrentTVLResponseFromJSON(jsonValue));
    }

    /**
     * Get TVL across all Drip Vaults.
     * Get current TVL across all vaults.
     */
    async v1AnalyticsTvlGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CurrentTVLResponse> {
        const response = await this.v1AnalyticsTvlGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get whirlpool config for dripOrcaWhirlpool.
     * Get Orca Whirlpool Swap Configs
     */
    async v1DripOrcawhirlpoolconfigsGetRaw(requestParameters: V1DripOrcawhirlpoolconfigsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<OrcaWhirlpoolConfig>>> {
        const queryParameters: any = {};

        if (requestParameters.vault !== undefined) {
            queryParameters['vault'] = requestParameters.vault;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/drip/orcawhirlpoolconfigs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OrcaWhirlpoolConfigFromJSON));
    }

    /**
     * Get whirlpool config for dripOrcaWhirlpool.
     * Get Orca Whirlpool Swap Configs
     */
    async v1DripOrcawhirlpoolconfigsGet(requestParameters: V1DripOrcawhirlpoolconfigsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<OrcaWhirlpoolConfig>> {
        const response = await this.v1DripOrcawhirlpoolconfigsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Drip Position Metadata
     */
    async v1DripPositionPubkeyPathMetadataGetRaw(requestParameters: V1DripPositionPubkeyPathMetadataGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokenMetadata>> {
        if (requestParameters.pubkeyPath === null || requestParameters.pubkeyPath === undefined) {
            throw new runtime.RequiredError('pubkeyPath','Required parameter requestParameters.pubkeyPath was null or undefined when calling v1DripPositionPubkeyPathMetadataGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/drip/position/{pubkeyPath}/metadata`.replace(`{${"pubkeyPath"}}`, encodeURIComponent(String(requestParameters.pubkeyPath))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenMetadataFromJSON(jsonValue));
    }

    /**
     * Get Drip Position Metadata
     */
    async v1DripPositionPubkeyPathMetadataGet(requestParameters: V1DripPositionPubkeyPathMetadataGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokenMetadata> {
        const response = await this.v1DripPositionPubkeyPathMetadataGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get TokenMetadata for Devnet Mints.
     */
    async v1DripPubkeyPathTokenmetadataGetRaw(requestParameters: V1DripPubkeyPathTokenmetadataGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokenMetadata>> {
        if (requestParameters.pubkeyPath === null || requestParameters.pubkeyPath === undefined) {
            throw new runtime.RequiredError('pubkeyPath','Required parameter requestParameters.pubkeyPath was null or undefined when calling v1DripPubkeyPathTokenmetadataGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/drip/{pubkeyPath}/tokenmetadata`.replace(`{${"pubkeyPath"}}`, encodeURIComponent(String(requestParameters.pubkeyPath))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenMetadataFromJSON(jsonValue));
    }

    /**
     * Get TokenMetadata for Devnet Mints.
     */
    async v1DripPubkeyPathTokenmetadataGet(requestParameters: V1DripPubkeyPathTokenmetadataGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokenMetadata> {
        const response = await this.v1DripPubkeyPathTokenmetadataGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get token swap config for DripSPLTokenSwap.
     * Get Token Swaps Configs
     */
    async v1DripSpltokenswapconfigsGetRaw(requestParameters: V1DripSpltokenswapconfigsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SplTokenSwapConfig>>> {
        const queryParameters: any = {};

        if (requestParameters.vault !== undefined) {
            queryParameters['vault'] = requestParameters.vault;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/drip/spltokenswapconfigs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SplTokenSwapConfigFromJSON));
    }

    /**
     * Get token swap config for DripSPLTokenSwap.
     * Get Token Swaps Configs
     */
    async v1DripSpltokenswapconfigsGet(requestParameters: V1DripSpltokenswapconfigsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SplTokenSwapConfig>> {
        const response = await this.v1DripSpltokenswapconfigsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all user positions.
     * Get User Positions
     */
    async v1PositionsGetRaw(requestParameters: V1PositionsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Position>>> {
        if (requestParameters.wallet === null || requestParameters.wallet === undefined) {
            throw new runtime.RequiredError('wallet','Required parameter requestParameters.wallet was null or undefined when calling v1PositionsGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.wallet !== undefined) {
            queryParameters['wallet'] = requestParameters.wallet;
        }

        if (requestParameters.isClosed !== undefined) {
            queryParameters['isClosed'] = requestParameters.isClosed;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/positions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PositionFromJSON));
    }

    /**
     * Get all user positions.
     * Get User Positions
     */
    async v1PositionsGet(requestParameters: V1PositionsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Position>> {
        const response = await this.v1PositionsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all supported proto configs.  If token filters are supplied, then the proto configs for vaults with those tokens will be returned. 
     * Get Proto Configs
     */
    async v1ProtoconfigsGetRaw(requestParameters: V1ProtoconfigsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ProtoConfig>>> {
        const queryParameters: any = {};

        if (requestParameters.tokenA !== undefined) {
            queryParameters['tokenA'] = requestParameters.tokenA;
        }

        if (requestParameters.tokenB !== undefined) {
            queryParameters['tokenB'] = requestParameters.tokenB;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/protoconfigs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProtoConfigFromJSON));
    }

    /**
     * Get all supported proto configs.  If token filters are supplied, then the proto configs for vaults with those tokens will be returned. 
     * Get Proto Configs
     */
    async v1ProtoconfigsGet(requestParameters: V1ProtoconfigsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ProtoConfig>> {
        const response = await this.v1ProtoconfigsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get token mint info by pubkey.
     * Get a Token
     */
    async v1TokenPubkeyPathGetRaw(requestParameters: V1TokenPubkeyPathGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Token>> {
        if (requestParameters.pubkeyPath === null || requestParameters.pubkeyPath === undefined) {
            throw new runtime.RequiredError('pubkeyPath','Required parameter requestParameters.pubkeyPath was null or undefined when calling v1TokenPubkeyPathGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/token/{pubkeyPath}`.replace(`{${"pubkeyPath"}}`, encodeURIComponent(String(requestParameters.pubkeyPath))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenFromJSON(jsonValue));
    }

    /**
     * Get token mint info by pubkey.
     * Get a Token
     */
    async v1TokenPubkeyPathGet(requestParameters: V1TokenPubkeyPathGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Token> {
        const response = await this.v1TokenPubkeyPathGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all tokens.
     * Get all Tokens (A and B).
     */
    async v1TokensGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Token>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/tokens`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenFromJSON));
    }

    /**
     * Get all tokens.
     * Get all Tokens (A and B).
     */
    async v1TokensGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Token>> {
        const response = await this.v1TokensGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get supported tokens with filters. If no params are passed, by default all supported tokenAs will be returned. 
     * Get all Supported Tokens
     */
    async v1VaultTokensGetRaw(requestParameters: V1VaultTokensGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Token>>> {
        const queryParameters: any = {};

        if (requestParameters.tokenA !== undefined) {
            queryParameters['tokenA'] = requestParameters.tokenA;
        }

        if (requestParameters.tokenB !== undefined) {
            queryParameters['tokenB'] = requestParameters.tokenB;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/vault/tokens`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenFromJSON));
    }

    /**
     * Get supported tokens with filters. If no params are passed, by default all supported tokenAs will be returned. 
     * Get all Supported Tokens
     */
    async v1VaultTokensGet(requestParameters: V1VaultTokensGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Token>> {
        const response = await this.v1VaultTokensGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get vault periods with pagination and filters.
     * Get Vault Periods
     */
    async v1VaultperiodsGetRaw(requestParameters: V1VaultperiodsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<VaultPeriod>>> {
        if (requestParameters.vault === null || requestParameters.vault === undefined) {
            throw new runtime.RequiredError('vault','Required parameter requestParameters.vault was null or undefined when calling v1VaultperiodsGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.vault !== undefined) {
            queryParameters['vault'] = requestParameters.vault;
        }

        if (requestParameters.vaultPeriod !== undefined) {
            queryParameters['vaultPeriod'] = requestParameters.vaultPeriod;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/vaultperiods`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(VaultPeriodFromJSON));
    }

    /**
     * Get vault periods with pagination and filters.
     * Get Vault Periods
     */
    async v1VaultperiodsGet(requestParameters: V1VaultperiodsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<VaultPeriod>> {
        const response = await this.v1VaultperiodsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all vaults with filters.
     * Get Supported Vaults
     */
    async v1VaultsGetRaw(requestParameters: V1VaultsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Vault>>> {
        const queryParameters: any = {};

        if (requestParameters.tokenA !== undefined) {
            queryParameters['tokenA'] = requestParameters.tokenA;
        }

        if (requestParameters.tokenB !== undefined) {
            queryParameters['tokenB'] = requestParameters.tokenB;
        }

        if (requestParameters.protoConfig !== undefined) {
            queryParameters['protoConfig'] = requestParameters.protoConfig;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/vaults`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(VaultFromJSON));
    }

    /**
     * Get all vaults with filters.
     * Get Supported Vaults
     */
    async v1VaultsGet(requestParameters: V1VaultsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Vault>> {
        const response = await this.v1VaultsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
